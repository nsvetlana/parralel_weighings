import math

def min_weighings(m, n, k, known_type=False):
    """
    Вычисляет минимальное число раундов взвешиваний для обнаружения m фальшивых монет среди n монет
    при наличии k весов (используемых параллельно).

    Параметры:
        m (int): число фальшивых монет.
        n (int): общее число монет.
        k (int): число весов.
        known_type (bool): если True, то считается, что отклонение фальшивых монет известно
                           (например, все фальшивые монеты легче или тяжелее);
                           если False — отклонение неизвестно (для каждой фальшивой монеты два варианта).

    Возвращает:
        int: минимальное число раундов взвешиваний, необходимое для различения всех вариантов.
    """
    # Вычисляем ln(binom(n, m)) через функцию math.lgamma:
    # ln(binom(n, m)) = ln(n!) - ln(m!) - ln((n-m)!)
    log_binom = math.lgamma(n + 1) - math.lgamma(m + 1) - math.lgamma(n - m + 1)

    if known_type:
        # Если тип отклонения известен, учитываем только выбор монет
        total_log = log_binom
    else:
        # Если тип отклонения неизвестен, учитываем, что для каждой фальшивой монеты есть два варианта (легче или тяжелее)
        total_log = m * math.log(2) + log_binom

    # Неравенство: total_log <= k * w * ln(3)
    # Решаем относительно w: w >= total_log / (k * ln(3))
    # Округляем вверх до целого числа
    w = math.ceil(total_log / (k * math.log(3)))
    return w

